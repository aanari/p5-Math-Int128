/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.24 from the
 * contents of Int128.xs. Do not edit this file, edit Int128.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "Int128.xs"
/* -*- Mode: C -*- */

#define PERL_NO_GET_CONTEXT 1

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include "ppport.h"

#include <stdint.h>
#include "perl_math_int64.h"

#if __GNUC__ == 4 && __GNUC_MINOR__ >= 4 && __GNUC_MINOR__ < 6

/* workaroung for gcc 4.4/4.5 - see http://gcc.gnu.org/gcc-4.4/changes.html */
typedef int int128_t __attribute__ ((__mode__ (TI)));
typedef unsigned int uint128_t __attribute__ ((__mode__ (TI)));

#else

typedef __int128 int128_t;
typedef unsigned __int128 uint128_t;

#endif

/* perl memory allocator does not guarantee 16-byte alignment */
typedef int128_t int128_t_a8 __attribute__ ((aligned(8)));
typedef uint128_t uint128_t_a8 __attribute__ ((aligned(8)));

#define I128LEN sizeof(int128_t)

#define INT128_MAX ((int128_t)((~(uint128_t)0)>>1))
#define INT128_MIN (~INT128_MAX)
#define UINT128_MAX (~(int128_t)0)

static int may_die_on_overflow = 0;

#if (PERL_VERSION >= 10)

#ifndef cop_hints_fetch_pvs
#define cop_hints_fetch_pvs(cop, key, flags) \
    Perl_refcounted_he_fetch(aTHX_ (cop)->cop_hints_hash, NULL, STR_WITH_LEN(key), (flags), 0)
#endif

static int
check_die_on_overflow_hint(pTHX) {
    SV *hint = cop_hints_fetch_pvs(PL_curcop, "Math::Int128::die_on_overflow", 0);
    return (hint && SvTRUE(hint));
}

#else

static int
check_die_on_overflow_hint(pTHX) {
    return 1;
}

#endif

static void
overflow(pTHX_ const char *msg) {
    if (check_die_on_overflow_hint(aTHX))
        Perl_croak(aTHX_ "Math::Int128 overflow: %s", msg);
}

#define get_int128_stash_uncached() gv_stashpvs("Math::Int128", 1)
#define get_uint128_stash_uncached() gv_stashpvs("Math::UInt128", 1)

#ifdef MULTIPLICITY
#  if defined(I_PTHREAD) && defined(PTHREAD_MUTEX_INITIALIZER)
#    define CACHE_STASHES
#  endif
#else
#  define CACHE_STASHES
#endif

#ifdef CACHE_STASHES
static HV * volatile int128_stash;
static HV * volatile uint128_stash;

#  ifdef MULTIPLICITY
static pthread_mutex_t stash_mutex = PTHREAD_MUTEX_INITIALIZER;
static int too_many_threads = 0;

static void init_stash_cache(pTHX) {
    pthread_mutex_lock(&stash_mutex);
    if (too_many_threads) {
        int128_stash = NULL;
        uint128_stash = NULL;
    }
    else {
        too_many_threads = 1;
        int128_stash = get_int128_stash_uncached();
        uint128_stash = get_uint128_stash_uncached();
    }
    pthread_mutex_unlock(&stash_mutex);
}

#  else

static void init_stash_cache(pTHX) {
    int128_stash = get_int128_stash_uncached();
    uint128_stash = get_uint128_stash_uncached();
}

#  endif

#define get_int128_stash() (int128_stash ? int128_stash : get_int128_stash_uncached())
#define get_uint128_stash() (uint128_stash ? uint128_stash : get_uint128_stash_uncached())

#else

static void init_stash_cache(pTHX) { }

#define get_int128_stash get_int128_stash_uncached
#define get_uint128_stash get_uint128_stash_uncached

#endif

static char *out_of_bounds_error_s = "Number is out of bounds for int128_t conversion";
static char *out_of_bounds_error_u = "Number is out of bounds for uint128_t conversion";
static char *mul_error             = "Multiplication overflows";
static char *pow_error             = "Exponentiation overflows";
static char *add_error             = "Addition overflows";
static char *sub_error             = "Subtraction overflows";
static char *inc_error             = "Increment operation wraps";
static char *dec_error             = "Decrement operation wraps";
static char *div_by_0_error        = "Illegal division by zero";

static void croak_string(pTHX_ const char *str) {
    Perl_croak(aTHX_ "%s", str);
}

#include <strtoint128.h>

#define SvI128Y(sv) (*((int128_t_a8*)SvPVX(sv)))
#define SvU128Y(sv) (*((uint128_t_a8*)SvPVX(sv)))
#define SVt_I128 SVt_PV

static SV *
new_si128(pTHX) {
    SV *si128 = newSV(I128LEN);
    SvPOK_on(si128);
    SvCUR_set(si128, I128LEN);
    return si128;
}

#define new_su128 new_si128

static SV *
newSVi128(pTHX_ int128_t i128) {
    HV *stash = get_int128_stash();
    SV *si128 = new_si128(aTHX);
    SV *sv;
    SvI128Y(si128) = i128;
    sv = newRV_noinc(si128);
    sv_bless(sv, stash);
    SvREADONLY_on(si128);
    return sv;
}

static SV *
newSVu128(pTHX_ uint128_t u128) {
    HV *stash = get_uint128_stash();
    SV *su128 = new_su128(aTHX);
    SV *sv;
    SvI128Y(su128) = u128;
    sv = newRV_noinc(su128);
    sv_bless(sv, stash);
    SvREADONLY_on(su128);
    return sv;
}

static int
SvI128OK(pTHX_ SV *sv) {
    if (SvROK(sv)) {
        SV *si128 = SvRV(sv);
        return (si128 && (SvTYPE(si128) >= SVt_I128) && sv_isa(sv, "Math::Int128"));
    }
    return 0;
}

static int
SvU128OK(pTHX_ SV *sv) {
    if (SvROK(sv)) {
        SV *su128 = SvRV(sv);
        return (su128 && (SvTYPE(su128) >= SVt_I128) && sv_isa(sv, "Math::UInt128"));
    }
    return 0;
}

#define SvI128X(sv) (SvI128Y(SvRV(sv)))
#define SvU128X(sv) (SvU128Y(SvRV(sv)))

static SV *
SvSI128(pTHX_ SV *sv) {
    if (SvROK(sv)) {
        SV *si128 = SvRV(sv);
        if (SvPOK(si128) && (SvCUR(si128) == I128LEN))
            return si128;
    }
    croak_string(aTHX_ "internal error: reference to int128_t expected");
    return NULL; /* never happens */
}

static SV *
SvSU128(pTHX_ SV *sv) {
    if (SvROK(sv)) {
        SV *su128 = SvRV(sv);
        if (SvPOK(su128) && (SvCUR(su128) == I128LEN))
            return su128;
    }
    croak_string(aTHX_ "internal error: reference to uint128_t expected");
    return NULL; /* never happens */
}

#define SvI128x(sv) SvI128Y(SvSI128(aTHX_ sv))
#define SvU128x(sv) SvU128Y(SvSU128(aTHX_ sv))

static int128_t
SvI128(pTHX_ SV *sv) {
    if (SvROK(sv)) {
        SV *si128 = SvRV(sv);
        if (si128 && SvOBJECT(si128)) {
            HV *stash = SvSTASH(si128);
#ifdef CACHE_STASHES
            if (stash == int128_stash) {
                return SvI128Y(si128);
            }
            else if (stash == uint128_stash) {
                int128_t u128 = SvU128Y(si128);
                if (may_die_on_overflow && (u128 > INT128_MAX))
                    overflow(aTHX_ out_of_bounds_error_s);
                return u128;
            }
#else
            if (0);
#endif
            else {
                GV *method;
                char const * classname = HvNAME_get(stash);
                if (memcmp(classname, "Math::", 6) == 0) {
                    int u;
                    if (classname[6] == 'U') {
                        classname += 7;
                        u = 1;
                    }
                    else {
                        classname += 6;
                        u = 0;
                    }
                    if (memcmp(classname, "Int", 3) == 0) {
                        classname += 3;
                        if (memcmp(classname, "128", 4) == 0) {
                            if (!SvPOK(si128) || (SvCUR(si128) != I128LEN))
                                Perl_croak(aTHX_ "Wrong internal representation for %s object", HvNAME_get(stash));
                            if (u) {
                                int128_t u128 = SvU128Y(si128);
                                if (may_die_on_overflow && (u128 > INT128_MAX))
                                    overflow(aTHX_ out_of_bounds_error_s);
                                return u128;
                            }
                            return SvI128Y(si128);
                        }
                        if (memcmp(classname, "64", 3) == 0) {
                            if (u) {
                                return SvU64(sv);
                            }
                            return SvI64(sv);
                        }
                    }
                }
                method = gv_fetchmethod(stash, "as_int128");
                if (method) {
                    SV *result;
                    int count;
                    dSP;
                    ENTER;
                    SAVETMPS;
                    PUSHSTACKi(PERLSI_MAGIC);
                    PUSHMARK(SP);
                    XPUSHs(sv);
                    PUTBACK;
                    count = perl_call_sv( (SV*)method, G_SCALAR );
                    SPAGAIN;
                    if (count != 1)
                        Perl_croak(aTHX_ "internal error: method call returned %d values, 1 expected", count);
                    result = newSVsv(POPs);
                    PUTBACK;
                    POPSTACK;
                    SPAGAIN;
                    FREETMPS;
                    LEAVE;
                    return SvI128(aTHX_ sv_2mortal(result));
                }
            }
        }
    }
    else {
        SvGETMAGIC(sv);
        if (SvIOK(sv)) {
            if (SvIOK_UV(sv))
                return SvUV(sv);
            return SvIV(sv);
        }
        if (SvNOK(sv)) {
            NV nv = SvNV(sv);
            if (may_die_on_overflow &&
                ((nv >= 0x1p127) || (nv < -0x1p127))) overflow(aTHX_ out_of_bounds_error_s);
            return nv;
        }
    }
    return strtoint128(aTHX_ SvPV_nolen(sv), 10, 1);
}

static uint128_t
SvU128(pTHX_ SV *sv) {
    if (SvROK(sv)) {
        SV *su128 = SvRV(sv);
        if (su128 && SvOBJECT(su128)) {
            HV *stash = SvSTASH(su128);
#ifdef CACHE_STASHES
            if (stash == uint128_stash)
                return SvU128Y(su128);
            else if (stash == int128_stash) {
                int128_t i128 = SvI128Y(su128);
                if (may_die_on_overflow && (i128 < 0))
                    overflow(aTHX_ out_of_bounds_error_u);
                return i128;
            }
#else
            if (0);
#endif
            else {
                GV *method;
                char const * classname = HvNAME_get(stash);
                if (memcmp(classname, "Math::", 6) == 0) {
                    int u;
                    if (classname[6] == 'U') {
                        classname += 7;
                        u = 1;
                    }
                    else {
                        classname += 6;
                        u = 0;
                    }
                    if (memcmp(classname, "Int", 3) == 0) {
                        classname += 3;
                        if (memcmp(classname, "128", 4) == 0) {
                            if (!SvPOK(su128) || (SvCUR(su128) != I128LEN))
                                Perl_croak(aTHX_ "Wrong internal representation for %s object", HvNAME_get(stash));
                            if (u)
                                return SvU128Y(su128);
                            else {
                                int128_t i128 = SvI128Y(su128);
                                if (may_die_on_overflow && (i128 < 0)) overflow(aTHX_ out_of_bounds_error_u);
                                return i128;
                            }
                        }
                        if (memcmp(classname, "64", 3) == 0) {
                            if (u) {
                                return SvU64(sv);
                            }
                            else {
                                int64_t i64 = SvI64(sv);
                                if (may_die_on_overflow && (i64 < 0)) overflow(aTHX_ out_of_bounds_error_u);
                                return i64;
                            }
                        }
                    }
                }
                method = gv_fetchmethod(stash, "as_uint128");
                if (method) {
                    SV *result;
                    int count;
                    dSP;
                    ENTER;
                    SAVETMPS;
                    PUSHSTACKi(PERLSI_MAGIC);
                    PUSHMARK(SP);
                    XPUSHs(sv);
                    PUTBACK;
                    count = perl_call_sv( (SV*)method, G_SCALAR );
                    SPAGAIN;
                    if (count != 1)
                        Perl_croak(aTHX_ "internal error: method call returned %d values, 1 expected", count);
                    result = newSVsv(POPs);
                    PUTBACK;
                    POPSTACK;
                    SPAGAIN;
                    FREETMPS;
                    LEAVE;
                    return SvU128(aTHX_ sv_2mortal(result));
                }
            }
        }
    }
    else {
        SvGETMAGIC(sv);
        if (SvIOK(sv)) {
            if (SvIOK_UV(sv))
                return SvUV(sv);
            else {
                IV iv = SvIV(sv);
                if (may_die_on_overflow && (iv < 0)) overflow(aTHX_ out_of_bounds_error_u);
                return iv;
            }
        }
        if (SvNOK(sv)) {
            NV nv = SvNV(sv);
            if (may_die_on_overflow && ((nv < 0) || (nv >= 0x1p128))) overflow(aTHX_ out_of_bounds_error_u);
            return nv;
        }
    }
    return strtoint128(aTHX_ SvPV_nolen(sv), 10, 0);
}

static SV *
si128_to_number(pTHX_ SV *sv) {
    int128_t i128 = SvI128(aTHX_ sv);
    if (i128 < 0) {
        IV iv = i128;
        if (iv == i128)
            return newSViv(iv);
    }
    else {
        UV uv = i128;
        if (uv == i128)
            return newSVuv(uv);
    }
    return newSVnv(i128);
}

static SV *
su128_to_number(pTHX_ SV *sv) {
    uint128_t u128 = SvU128(aTHX_ sv);
    UV uv;
    uv = u128;
    if (uv == u128)
        return newSVuv(uv);
    return newSVnv(u128);
}

#define I128STRLEN 44

static STRLEN
u128_to_string(uint128_t u128, char *to) {
    char str[I128STRLEN];
    int i, len = 0;
    while (u128) {
        str[len++] = '0' + u128 % 10;
        u128 /= 10;
    }
    if (len) {
        for (i = len; i--;) *(to++) = str[i];
        return len;
    }
    else {
        to[0] = '0';
        return 1;
    }
}

static STRLEN
i128_to_string(int128_t i128, char *to) {
    if (i128 < 0) {
        *(to++) = '-';
        return u128_to_string(-i128, to) + 1;
    }
    return u128_to_string(i128, to);
}

static void
u128_to_hex(uint128_t i128, char *to) {
    int i = I128LEN * 2;
    while (i--) {
        int v = i128 & 15;
        to[i] = v + ((v > 9) ? ('A' - 10) : '0');
        i128 >>= 4;
    }
}

static void
mul_check_overflow(pTHX_ uint128_t a, uint128_t b, const char *error_str) {
    if (a < b) {
        uint128_t tmp = a;
        a = b; b = tmp;
    }
    if (b > UINT64_MAX) overflow(aTHX_ error_str);
    else {
        uint128_t rl, rh;
        rl = (a & UINT64_MAX) * b;
        rh = (a >> 64) * b + (rl >> 64);
        if (rh > UINT64_MAX) overflow(aTHX_ error_str);
    }
}

static uint128_t
powU128(pTHX_ uint128_t a, uint128_t b) {
    uint128_t r;
    int mdoo = may_die_on_overflow;
    if (b == 0) return 1;
    if (b == 1) return a;
    if (b == 2) {
        if (mdoo && (a > UINT64_MAX)) overflow(aTHX_ pow_error);
        return a*a;
    }
    if (a == 0) return 0;
    if (a == 1) return 1;
    if (a == 2) {
        if (b > 127) {
            if (mdoo) overflow(aTHX_ pow_error);
            return 0;
        }
        return (((uint128_t)1) << b);
    }
    if (mdoo) {
        r = ((b & 1) ? a : 1);
        while ((b >>= 1)) {
            if (a > UINT64_MAX) overflow(aTHX_ pow_error);
            a *= a;
            if (b & 1) {
                mul_check_overflow(aTHX_ r, a, pow_error);
                r *= a;
            }
        }
    }
    else {
        r = 1;
        while (b) {
            if (b & 1) r *= a;
            a *= a;
            b >>= 1;
        }
    }
    return r;
}

#include "c_api.h"

#line 551 "Int128.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)    S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage        S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 693 "Int128.c"

XS_EUPXS(XS_Math__Int128_CLONE); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_CLONE)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
#line 551 "Int128.xs"
    init_stash_cache(aTHX);
#line 704 "Int128.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Math__Int128__set_may_die_on_overflow); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128__set_may_die_on_overflow)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "v");
    {
	int	v = (int)SvIV(ST(0))
;
#line 557 "Int128.xs"
    may_die_on_overflow = v;
#line 721 "Int128.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Math__Int128_int128); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_int128)
{
    dVAR; dXSARGS;
    if (items < 0 || items > 1)
       croak_xs_usage(cv,  "value=0");
    {
	SV *	value;
	SV *	RETVAL;

	if (items < 1)
	    value = 0;
	else {
	    value = ST(0)
;
	}
#line 563 "Int128.xs"
    RETVAL = newSVi128(aTHX_ (value ? SvI128(aTHX_ value) : 0));
#line 745 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__Int128_uint128); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_uint128)
{
    dVAR; dXSARGS;
    if (items < 0 || items > 1)
       croak_xs_usage(cv,  "value=0");
    {
	SV *	value;
	SV *	RETVAL;

	if (items < 1)
	    value = 0;
	else {
	    value = ST(0)
;
	}
#line 571 "Int128.xs"
    RETVAL = newSVu128(aTHX_ (value ? SvU128(aTHX_ value) : 0));
#line 771 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__Int128_int128_to_number); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_int128_to_number)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0)
;
	SV *	RETVAL;
#line 579 "Int128.xs"
    RETVAL = si128_to_number(aTHX_ self);
#line 791 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__Int128_uint128_to_number); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_uint128_to_number)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0)
;
	SV *	RETVAL;
#line 587 "Int128.xs"
    RETVAL = su128_to_number(aTHX_ self);
#line 811 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__Int128_net_to_int128); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_net_to_int128)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "net");
    {
	SV *	net = ST(0)
;
#line 595 "Int128.xs"
    STRLEN len;
    unsigned char *pv = (unsigned char *)SvPV(net, len);
#line 831 "Int128.c"
	SV *	RETVAL;
#line 598 "Int128.xs"
    if (len != 16)
        croak_string(aTHX_ "Invalid length for int128_t");
    RETVAL = newSVi128(aTHX_
                       (((((((((((((((((((((((((((((((int128_t)pv[0]) << 8)
                                                   + (int128_t)pv[1]) << 8)
                                                 + (int128_t)pv[2]) << 8)
                                               + (int128_t)pv[3]) << 8)
                                             + (int128_t)pv[4]) << 8)
                                           + (int128_t)pv[5]) << 8)
                                         + (int128_t)pv[6]) << 8)
                                       + (int128_t)pv[7]) << 8)
                                     + (int128_t)pv[8]) << 8)
                                   + (int128_t)pv[9]) << 8)
                                 + (int128_t)pv[10]) << 8)
                               + (int128_t)pv[11]) << 8)
                             + (int128_t)pv[12]) << 8)
                           + (int128_t)pv[13]) << 8)
                         + (int128_t)pv[14]) << 8)
                       + (int128_t)pv[15]);
#line 853 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__Int128_net_to_uint128); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_net_to_uint128)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "net");
    {
	SV *	net = ST(0)
;
#line 624 "Int128.xs"
    STRLEN len;
    unsigned char *pv = (unsigned char *)SvPV(net, len);
#line 873 "Int128.c"
	SV *	RETVAL;
#line 627 "Int128.xs"
    if (len != 16)
        croak_string(aTHX_ "Invalid length for uint128_t");
    RETVAL = newSVu128(aTHX_
                       (((((((((((((((((((((((((((((((uint128_t)pv[0]) << 8)
                                                   + (uint128_t)pv[1]) << 8)
                                                 + (uint128_t)pv[2]) << 8)
                                               + (uint128_t)pv[3]) << 8)
                                             + (uint128_t)pv[4]) << 8)
                                           + (uint128_t)pv[5]) << 8)
                                         + (uint128_t)pv[6]) << 8)
                                       + (uint128_t)pv[7]) << 8)
                                     + (uint128_t)pv[8]) << 8)
                                   + (uint128_t)pv[9]) << 8)
                                 + (uint128_t)pv[10]) << 8)
                               + (uint128_t)pv[11]) << 8)
                             + (uint128_t)pv[12]) << 8)
                           + (uint128_t)pv[13]) << 8)
                         + (uint128_t)pv[14]) << 8)
                       + (uint128_t)pv[15]);
#line 895 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__Int128_int128_to_net); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_int128_to_net)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0)
;
#line 653 "Int128.xs"
    char *pv;
    int128_t i128 = SvI128(aTHX_ self);
    int i;
#line 916 "Int128.c"
	SV *	RETVAL;
#line 657 "Int128.xs"
    RETVAL = newSV(I128LEN);
    SvPOK_on(RETVAL);
    SvCUR_set(RETVAL, I128LEN);
    pv = SvPVX(RETVAL);
    pv[I128LEN] = '\0';
    for (i = I128LEN - 1; i >= 0; i--, i128 >>= 8)
        pv[i] = i128;
#line 926 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__Int128_uint128_to_net); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_uint128_to_net)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0)
;
#line 671 "Int128.xs"
    char *pv;
    uint128_t u128 = SvU128(aTHX_ self);
    int i;
#line 947 "Int128.c"
	SV *	RETVAL;
#line 675 "Int128.xs"
    RETVAL = newSV(I128LEN);
    SvPOK_on(RETVAL);
    SvCUR_set(RETVAL, I128LEN);
    pv = SvPVX(RETVAL);
    pv[I128LEN] = '\0';
    for (i = I128LEN - 1; i >= 0; i--, u128 >>= 8)
        pv[i] = u128;
#line 957 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__Int128_native_to_int128); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_native_to_int128)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "native");
    {
	SV *	native = ST(0)
;
#line 689 "Int128.xs"
    STRLEN len;
    char *pv = SvPV(native, len);
#line 977 "Int128.c"
	SV *	RETVAL;
#line 692 "Int128.xs"
    if (len != I128LEN)
        croak_string(aTHX_ "Invalid length for int128_t");
    RETVAL = newSVi128(aTHX_ 0);
    Copy(pv, &(SvI128X(RETVAL)), I128LEN, char);
#line 984 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__Int128_native_to_uint128); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_native_to_uint128)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "native");
    {
	SV *	native = ST(0)
;
#line 703 "Int128.xs"
    STRLEN len;
    char *pv = SvPV(native, len);
#line 1004 "Int128.c"
	SV *	RETVAL;
#line 706 "Int128.xs"
    if (len != I128LEN)
        croak_string(aTHX_ "Invalid length for uint128_t");
    RETVAL = newSVu128(aTHX_ 0);
    Copy(pv, &(SvU128X(RETVAL)), I128LEN, char);
#line 1011 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__Int128_int128_to_native); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_int128_to_native)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0)
;
#line 717 "Int128.xs"
    char *pv;
    int128_t i128 = SvI128(aTHX_ self);
#line 1031 "Int128.c"
	SV *	RETVAL;
#line 720 "Int128.xs"
    RETVAL = newSV(I128LEN);
    SvPOK_on(RETVAL);
    SvCUR_set(RETVAL, I128LEN);
    pv = SvPVX(RETVAL);
    Copy(&i128, pv, I128LEN, char);
    pv[I128LEN] = '\0';
#line 1040 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__Int128_uint128_to_native); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_uint128_to_native)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0)
;
#line 733 "Int128.xs"
    char *pv;
    uint128_t u128 = SvU128(aTHX_ self);
#line 1060 "Int128.c"
	SV *	RETVAL;
#line 736 "Int128.xs"
    RETVAL = newSV(I128LEN);
    SvPOK_on(RETVAL);
    SvCUR_set(RETVAL, I128LEN);
    pv = SvPVX(RETVAL);
    Copy(&u128, pv, I128LEN, char);
    pv[I128LEN] = '\0';
#line 1069 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__Int128_uint128_to_hex); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_uint128_to_hex)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0)
;
#line 749 "Int128.xs"
    char *pv;
    uint128_t u128 = SvU128(aTHX_ self);
#line 1089 "Int128.c"
	SV *	RETVAL;
#line 752 "Int128.xs"
    RETVAL = newSV(I128LEN * 2);
    SvPOK_on(RETVAL);
    SvCUR_set(RETVAL, I128LEN * 2);
    pv = SvPVX(RETVAL);
    u128_to_hex(u128, pv);
#line 1097 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__Int128_int128_to_hex); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_int128_to_hex)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0)
;
#line 764 "Int128.xs"
    char *pv;
    uint128_t u128 = SvI128(aTHX_ self);
#line 1117 "Int128.c"
	SV *	RETVAL;
#line 767 "Int128.xs"
    RETVAL = newSV(I128LEN * 2);
    SvPOK_on(RETVAL);
    SvCUR_set(RETVAL, I128LEN * 2);
    pv = SvPVX(RETVAL);
    u128_to_hex(u128, pv);
#line 1125 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__Int128_string_to_int128); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_string_to_int128)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "str, base = 0");
    {
	const char *	str = (const char *)SvPV_nolen(ST(0))
;
	int	base;
	SV *	RETVAL;

	if (items < 2)
	    base = 0;
	else {
	    base = (int)SvIV(ST(1))
;
	}
#line 780 "Int128.xs"
    RETVAL = newSVi128(aTHX_ strtoint128(aTHX_ str, base, 1));
#line 1153 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__Int128_string_to_uint128); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_string_to_uint128)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "str, base = 0");
    {
	const char *	str = (const char *)SvPV_nolen(ST(0))
;
	int	base;
	SV *	RETVAL;

	if (items < 2)
	    base = 0;
	else {
	    base = (int)SvIV(ST(1))
;
	}
#line 789 "Int128.xs"
    RETVAL = newSVu128(aTHX_ strtoint128(aTHX_ str, base, 0));
#line 1181 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__Int128__inc); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128__inc)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "self, ...");
    {
	SV *	self = ST(0)
;
#line 800 "Int128.xs"
    int128_t i128 = SvI128x(self);
#line 1200 "Int128.c"
	SV *	RETVAL;
#line 802 "Int128.xs"
    if (may_die_on_overflow && (i128 == INT128_MAX)) overflow(aTHX_ inc_error);
    SvI128x(self) = i128 + 1;
    RETVAL = self;
    SvREFCNT_inc(RETVAL);
#line 1207 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__Int128__dec); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128__dec)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "self, ...");
    {
	SV *	self = ST(0)
;
#line 813 "Int128.xs"
    int128_t i128 = SvI128x(self);
#line 1226 "Int128.c"
	SV *	RETVAL;
#line 815 "Int128.xs"
    if (may_die_on_overflow && (i128 == 0)) overflow(aTHX_ dec_error);
    SvI128x(self) = i128 - 1;
    RETVAL = self;
    SvREFCNT_inc(RETVAL);
#line 1233 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__Int128__add); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128__add)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, other, rev");
    {
	SV *	self = ST(0)
;
	SV *	other = ST(1)
;
	SV *	rev = ST(2)
;
#line 828 "Int128.xs"
    int128_t a = SvI128x(self);
    int128_t b = SvI128(aTHX_ other);
#line 1257 "Int128.c"
	SV *	RETVAL;
#line 831 "Int128.xs"
    if ( may_die_on_overflow &&
         ( a > 0
           ? ( (b > 0) && (INT128_MAX - a < b) )
           : ( (b < 0) && (INT128_MIN - a > b) ) ) ) overflow(aTHX_ add_error);
    if (SvOK(rev)) 
        RETVAL = newSVi128(aTHX_ a + b);
    else {
        RETVAL = self;
        SvREFCNT_inc(RETVAL);
        SvI128x(self) = a + b;
    }
#line 1271 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__Int128__sub); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128__sub)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, other, rev");
    {
	SV *	self = ST(0)
;
	SV *	other = ST(1)
;
	SV *	rev = ST(2)
;
#line 851 "Int128.xs"
    int128_t a = SvI128x(self);
    int128_t b = SvI128(aTHX_ other);
#line 1295 "Int128.c"
	SV *	RETVAL;
#line 854 "Int128.xs"
    if (SvTRUE(rev)) {
        int128_t tmp = a;
        a = b; b = tmp;
    }
    if ( may_die_on_overflow &&
         ( a > 0
           ? ( (b < 0) && (a - INT128_MAX > b) )
           : ( (b > 0) && (a - INT128_MIN < b) ) ) ) overflow(aTHX_ sub_error);
    if (SvOK(rev))
        RETVAL = newSVi128(aTHX_ a - b);
    else {
        RETVAL = self;
        SvREFCNT_inc(RETVAL);
        SvI128x(self) = a - b;
    }
#line 1313 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__Int128__mul); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128__mul)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, other, rev");
    {
	SV *	self = ST(0)
;
	SV *	other = ST(1)
;
	SV *	rev = ST(2)
;
#line 878 "Int128.xs"
    int128_t a1 = SvI128x(self);
    int128_t b1 = SvI128(aTHX_ other);
#line 1337 "Int128.c"
	SV *	RETVAL;
#line 881 "Int128.xs"
    if (may_die_on_overflow) {
        int neg = 0;
        uint128_t a, b;
        if (a1 < 0) {
            a = -a1;
            neg ^= 1;
        }
        else a = a1;
        if (b1 < 0) {
            b = -b1;
            neg ^= 1;
        }
        else b = b1;
        mul_check_overflow(aTHX_ a, b, mul_error);
        if (a * b > (neg ? (~(uint128_t)INT128_MIN + 1) : INT128_MAX)) overflow(aTHX_ mul_error);
    }
    if (SvOK(rev))
        RETVAL = newSVi128(aTHX_ a1 * b1);
    else {
        RETVAL = self;
        SvREFCNT_inc(RETVAL);
        SvI128x(self) = a1 * b1;
    }
#line 1363 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__Int128__div); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128__div)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, other, rev");
    {
	SV *	self = ST(0)
;
	SV *	other = ST(1)
;
	SV *	rev = ST(2)
;
#line 913 "Int128.xs"
    int128_t up;
    int128_t down;
#line 1387 "Int128.c"
	SV *	RETVAL;
#line 916 "Int128.xs"
    if (SvOK(rev)) {
        if (SvTRUE(rev)) {
            up = SvI128(aTHX_ other);
            down = SvI128x(self);
        }
        else {
            up = SvI128x(self);
            down = SvI128(aTHX_ other);
        }
        if (!down)
            croak_string(aTHX_ div_by_0_error);
        RETVAL = newSVi128(aTHX_ up/down);
    }
    else {
        down = SvI128(aTHX_ other);
        if (!down)
            croak_string(aTHX_ div_by_0_error);
        RETVAL = self;
        SvREFCNT_inc(RETVAL);
        SvI128x(self) /= down;
    }
#line 1411 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__Int128__remainder); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128__remainder)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, other, rev");
    {
	SV *	self = ST(0)
;
	SV *	other = ST(1)
;
	SV *	rev = ST(2)
;
#line 946 "Int128.xs"
    int128_t up;
    int128_t down;
#line 1435 "Int128.c"
	SV *	RETVAL;
#line 949 "Int128.xs"
    if (SvOK(rev)) {
        if (SvTRUE(rev)) {
            up = SvI128(aTHX_ other);
            down = SvI128x(self);
        }
        else {
            up = SvI128x(self);
            down = SvI128(aTHX_ other);
        }
        if (!down)
            croak_string(aTHX_ div_by_0_error);
        RETVAL = newSVi128(aTHX_ up % down);
    }
    else {
        down = SvI128(aTHX_ other);
        if (!down)
            croak_string(aTHX_ div_by_0_error);
        RETVAL = self;
        SvREFCNT_inc(RETVAL);
        SvI128x(self) %= down;
    }
#line 1459 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__Int128__left); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128__left)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, other, rev");
    {
	SV *	self = ST(0)
;
	SV *	other = ST(1)
;
	SV *	rev = ST(2)
;
	SV *	RETVAL;
#line 978 "Int128.xs"
    if (SvOK(rev)) {
        uint128_t a, b;
        if (SvTRUE(rev)) {
            a = SvU128(aTHX_ other);
            b = SvU128x(self);
        }
        else {
            b = SvU128(aTHX_ other);
            a = SvI128x(self);
        }
        RETVAL = newSVi128(aTHX_ (uint128_t)(b > 127 ? 0 : a << b));
    }
    else {
        uint128_t b = SvU128(aTHX_ other);
        RETVAL = SvREFCNT_inc(self);
        SvI128x(self) <<= (b > 128 ? 128 : b);
    }
#line 1499 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__Int128__right); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128__right)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, other, rev");
    {
	SV *	self = ST(0)
;
	SV *	other = ST(1)
;
	SV *	rev = ST(2)
;
#line 1003 "Int128.xs"
    int128_t a;
    uint128_t b;
#line 1523 "Int128.c"
	SV *	RETVAL;
#line 1006 "Int128.xs"
    if (SvOK(rev)) {
        if (SvTRUE(rev)) {
            a = SvI128(aTHX_ other);
            b = SvU128x(self);
        }
        else {
            b = SvU128(aTHX_ other);
            a = SvI128x(self);
        }
        RETVAL = newSVi128(aTHX_ a >> (b > 127 ? 127 : b));
    }
    else {
        b = SvU128(aTHX_ other);
        RETVAL = SvREFCNT_inc(self);
        SvI128x(self) >>= (b > 127 ? 127 : b);
    }
#line 1542 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__Int128__pow); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128__pow)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "self, other, rev = &PL_sv_no");
    {
	SV *	self = ST(0)
;
	SV *	other = ST(1)
;
	SV *	rev;
#line 1030 "Int128.xs"
    int sign;
    uint128_t r;
    int128_t a, b;
#line 1566 "Int128.c"
	SV *	RETVAL;

	if (items < 3)
	    rev = &PL_sv_no;
	else {
	    rev = ST(2)
;
	}
#line 1034 "Int128.xs"
    if (SvTRUE(rev)) {
        a = SvI128(aTHX_ other);
        b = SvI128x(self);
    }
    else {
        a = SvI128x(self);
        b = SvI128(aTHX_ other);
    }
    if (a < 0) {
        sign = ((b & 1) ? -1 : 1);
        a = -a;
    }
    else sign = 1;
    if (b < 0) {
        if      (a == 0) croak_string(aTHX_ div_by_0_error);
        else if (a == 1) r = sign;
        else             r = 0;
    }
    else {
        uint128_t u = powU128(aTHX_ a, b);
        if (may_die_on_overflow && (u > ((sign < 0) ? (~(uint128_t)INT128_MIN + 1) : INT128_MAX))) overflow(aTHX_ pow_error);
        r = ((sign > 0) ? u : -u);
    }
    if (SvOK(rev))
        RETVAL = newSVi128(aTHX_ r);
    else {
        RETVAL = self;
        SvREFCNT_inc(RETVAL);
        SvI128x(self) = r;
    }
#line 1606 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__Int128__spaceship); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128__spaceship)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, other, rev");
    {
	SV *	self = ST(0)
;
	SV *	other = ST(1)
;
	SV *	rev = ST(2)
;
#line 1073 "Int128.xs"
    int128_t left;
    int128_t right;
#line 1630 "Int128.c"
	int	RETVAL;
	dXSTARG;
#line 1076 "Int128.xs"
    if (SvTRUE(rev)) {
        left = SvI128(aTHX_ other);
        right = SvI128x(self);
    }
    else {
        left = SvI128x(self);
        right = SvI128(aTHX_ other);
    }
    RETVAL = (left < right ? -1 : left > right ? 1 : 0);
#line 1643 "Int128.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__Int128__eqn); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128__eqn)
{
    dVAR; dXSARGS;
    if (items < 2)
       croak_xs_usage(cv,  "self, other, ...");
    {
	SV *	self = ST(0)
;
	SV *	other = ST(1)
;
	SV *	RETVAL;
#line 1093 "Int128.xs"
    RETVAL = ( SvI128x(self) == SvI128(aTHX_ other)
               ? &PL_sv_yes
               : &PL_sv_no );
#line 1666 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__Int128__nen); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128__nen)
{
    dVAR; dXSARGS;
    if (items < 2)
       croak_xs_usage(cv,  "self, other, ...");
    {
	SV *	self = ST(0)
;
	SV *	other = ST(1)
;
	SV *	RETVAL;
#line 1104 "Int128.xs"
    RETVAL = ( SvI128x(self) != SvI128(aTHX_ other)
               ? &PL_sv_yes
               : &PL_sv_no );
#line 1690 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__Int128__gtn); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128__gtn)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, other, rev");
    {
	SV *	self = ST(0)
;
	SV *	other = ST(1)
;
	SV *	rev = ST(2)
;
	SV *	RETVAL;
#line 1116 "Int128.xs"
    if (SvTRUE(rev))
        RETVAL = SvI128x(self) < SvI128(aTHX_ other) ? &PL_sv_yes : &PL_sv_no;
    else
        RETVAL = SvI128x(self) > SvI128(aTHX_ other) ? &PL_sv_yes : &PL_sv_no;
#line 1717 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__Int128__ltn); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128__ltn)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, other, rev");
    {
	SV *	self = ST(0)
;
	SV *	other = ST(1)
;
	SV *	rev = ST(2)
;
	SV *	RETVAL;
#line 1129 "Int128.xs"
    if (SvTRUE(rev))
        RETVAL = SvI128x(self) > SvI128(aTHX_ other) ? &PL_sv_yes : &PL_sv_no;
    else
        RETVAL = SvI128x(self) < SvI128(aTHX_ other) ? &PL_sv_yes : &PL_sv_no;
#line 1744 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__Int128__gen); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128__gen)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, other, rev");
    {
	SV *	self = ST(0)
;
	SV *	other = ST(1)
;
	SV *	rev = ST(2)
;
	SV *	RETVAL;
#line 1142 "Int128.xs"
    if (SvTRUE(rev))
        RETVAL = SvI128x(self) <= SvI128(aTHX_ other) ? &PL_sv_yes : &PL_sv_no;
    else
        RETVAL = SvI128x(self) >= SvI128(aTHX_ other) ? &PL_sv_yes : &PL_sv_no;
#line 1771 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__Int128__len); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128__len)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, other, rev");
    {
	SV *	self = ST(0)
;
	SV *	other = ST(1)
;
	SV *	rev = ST(2)
;
	SV *	RETVAL;
#line 1155 "Int128.xs"
    if (SvTRUE(rev))
        RETVAL = SvI128x(self) >= SvI128(aTHX_ other) ? &PL_sv_yes : &PL_sv_no;
    else
        RETVAL = SvI128x(self) <= SvI128(aTHX_ other) ? &PL_sv_yes : &PL_sv_no;
#line 1798 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__Int128__and); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128__and)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, other, rev");
    {
	SV *	self = ST(0)
;
	SV *	other = ST(1)
;
	SV *	rev = ST(2)
;
	SV *	RETVAL;
#line 1168 "Int128.xs"
    if (SvOK(rev))
        RETVAL = newSVi128(aTHX_ SvI128x(self) & SvI128(aTHX_ other));
    else {
        RETVAL = self;
        SvREFCNT_inc(RETVAL);
        SvI128x(self) &= SvI128(aTHX_ other);
    }
#line 1828 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__Int128__or); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128__or)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, other, rev");
    {
	SV *	self = ST(0)
;
	SV *	other = ST(1)
;
	SV *	rev = ST(2)
;
	SV *	RETVAL;
#line 1184 "Int128.xs"
    if (SvOK(rev))
        RETVAL = newSVi128(aTHX_ SvI128x(self) | SvI128(aTHX_ other));
    else {
        RETVAL = self;
        SvREFCNT_inc(RETVAL);
        SvI128x(self) |= SvI128(aTHX_ other);
    }
#line 1858 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__Int128__xor); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128__xor)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, other, rev");
    {
	SV *	self = ST(0)
;
	SV *	other = ST(1)
;
	SV *	rev = ST(2)
;
	SV *	RETVAL;
#line 1200 "Int128.xs"
    if (SvOK(rev))
        RETVAL = newSVi128(aTHX_ SvI128x(self) ^ SvI128(aTHX_ other));
    else {
        RETVAL = self;
        SvREFCNT_inc(RETVAL);
        SvI128x(self) ^= SvI128(aTHX_ other);
    }
#line 1888 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__Int128__not); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128__not)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "self, ...");
    {
	SV *	self = ST(0)
;
	SV *	RETVAL;
#line 1214 "Int128.xs"
    RETVAL = SvI128x(self) ? &PL_sv_no : &PL_sv_yes;
#line 1908 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__Int128__bnot); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128__bnot)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "self, ...");
    {
	SV *	self = ST(0)
;
	SV *	RETVAL;
#line 1222 "Int128.xs"
    RETVAL = newSVi128(aTHX_ ~SvI128x(self));
#line 1928 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__Int128__neg); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128__neg)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "self, ...");
    {
	SV *	self = ST(0)
;
	SV *	RETVAL;
#line 1230 "Int128.xs"
    RETVAL = newSVi128(aTHX_ -SvI128x(self));
#line 1948 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__Int128__bool); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128__bool)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "self, ...");
    {
	SV *	self = ST(0)
;
	SV *	RETVAL;
#line 1238 "Int128.xs"
    RETVAL = SvI128x(self) ? &PL_sv_yes : &PL_sv_no;
#line 1968 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__Int128__number); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128__number)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "self, ...");
    {
	SV *	self = ST(0)
;
	SV *	RETVAL;
#line 1246 "Int128.xs"
    RETVAL = si128_to_number(aTHX_ self);
#line 1988 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__Int128__clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128__clone)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "self, ...");
    {
	SV *	self = ST(0)
;
	SV *	RETVAL;
#line 1254 "Int128.xs"
    RETVAL = newSVi128(aTHX_ SvI128x(self));
#line 2008 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__Int128__string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128__string)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "self, ...");
    {
	SV *	self = ST(0)
;
	SV *	RETVAL;
#line 1262 "Int128.xs"
    RETVAL = newSV(I128STRLEN);
    SvPOK_on(RETVAL);
    SvCUR_set(RETVAL, i128_to_string(SvI128x(self), SvPVX(RETVAL)));
#line 2030 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__UInt128__inc); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__UInt128__inc)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "self, ...");
    {
	SV *	self = ST(0)
;
	SV *	RETVAL;
#line 1276 "Int128.xs"
    if (may_die_on_overflow && (SvU128x(self) == UINT128_MAX)) overflow(aTHX_ inc_error);
    SvU128x(self)++;
    RETVAL = SvREFCNT_inc(self);
#line 2052 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__UInt128__dec); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__UInt128__dec)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "self, ...");
    {
	SV *	self = ST(0)
;
	SV *	RETVAL;
#line 1286 "Int128.xs"
    if (may_die_on_overflow && (SvU128x(self) == 0)) overflow(aTHX_ dec_error);
    SvU128x(self)--;
    RETVAL = SvREFCNT_inc(self);
#line 2074 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__UInt128__add); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__UInt128__add)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, other, rev");
    {
	SV *	self = ST(0)
;
	SV *	other = ST(1)
;
	SV *	rev = ST(2)
;
#line 1298 "Int128.xs"
    uint128_t a = SvU128x(self);
    uint128_t b = SvU128(aTHX_ other);
#line 2098 "Int128.c"
	SV *	RETVAL;
#line 1301 "Int128.xs"
    if (may_die_on_overflow && (UINT128_MAX - a < b)) overflow(aTHX_ add_error);
    if (SvOK(rev)) 
        RETVAL = newSVu128(aTHX_ a + b);
    else {
        RETVAL = self;
        SvREFCNT_inc(RETVAL);
        SvU128x(self) = a + b;
    }
#line 2109 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__UInt128__sub); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__UInt128__sub)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, other, rev");
    {
	SV *	self = ST(0)
;
	SV *	other = ST(1)
;
	SV *	rev = ST(2)
;
#line 1318 "Int128.xs"
    uint128_t a, b;
#line 2132 "Int128.c"
	SV *	RETVAL;
#line 1320 "Int128.xs"
    if (SvTRUE(rev)) {
        a = SvU128(aTHX_ other);
        b = SvU128x(self);
    }
    else {
        a = SvU128x(self);
        b = SvU128(aTHX_ other);
    }
    if (may_die_on_overflow && (b > a)) overflow(aTHX_ sub_error);
    if (SvOK(rev))
        RETVAL = newSVu128(aTHX_ a - b);
    else {
        RETVAL = SvREFCNT_inc(self);
        SvU128x(self) = a - b;
    }
#line 2150 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__UInt128__mul); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__UInt128__mul)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, other, rev");
    {
	SV *	self = ST(0)
;
	SV *	other = ST(1)
;
	SV *	rev = ST(2)
;
#line 1344 "Int128.xs"
    uint128_t a = SvU128x(self);
    uint128_t b = SvU128(aTHX_ other);
#line 2174 "Int128.c"
	SV *	RETVAL;
#line 1347 "Int128.xs"
    if (may_die_on_overflow)
        mul_check_overflow(aTHX_ a, b, mul_error);
    if (SvOK(rev))
        RETVAL = newSVu128(aTHX_ a * b);
    else {
        RETVAL = SvREFCNT_inc(self);
        SvU128x(self) = a * b;
    }
#line 2185 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__UInt128__div); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__UInt128__div)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, other, rev");
    {
	SV *	self = ST(0)
;
	SV *	other = ST(1)
;
	SV *	rev = ST(2)
;
#line 1364 "Int128.xs"
    uint128_t up;
    uint128_t down;
#line 2209 "Int128.c"
	SV *	RETVAL;
#line 1367 "Int128.xs"
    if (SvOK(rev)) {
        if (SvTRUE(rev)) {
            up = SvU128(aTHX_ other);
            down = SvU128x(self);
        }
        else {
            up = SvU128x(self);
            down = SvU128(aTHX_ other);
        }
        if (!down)
            croak_string(aTHX_ div_by_0_error);
        RETVAL = newSVu128(aTHX_ up/down);
    }
    else {
        down = SvU128(aTHX_ other);
        if (!down)
            croak_string(aTHX_ div_by_0_error);
        RETVAL = self;
        SvREFCNT_inc(RETVAL);
        SvU128x(self) /= down;
    }
#line 2233 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__UInt128__remainder); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__UInt128__remainder)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, other, rev");
    {
	SV *	self = ST(0)
;
	SV *	other = ST(1)
;
	SV *	rev = ST(2)
;
#line 1397 "Int128.xs"
    uint128_t up;
    uint128_t down;
#line 2257 "Int128.c"
	SV *	RETVAL;
#line 1400 "Int128.xs"
    if (SvOK(rev)) {
        if (SvTRUE(rev)) {
            up = SvU128(aTHX_ other);
            down = SvU128x(self);
        }
        else {
            up = SvU128x(self);
            down = SvU128(aTHX_ other);
        }
        if (!down)
            croak_string(aTHX_ div_by_0_error);
        RETVAL = newSVu128(aTHX_ up % down);
    }
    else {
        down = SvU128(aTHX_ other);
        if (!down)
            croak_string(aTHX_ div_by_0_error);
        RETVAL = self;
        SvREFCNT_inc(RETVAL);
        SvU128x(self) %= down;
    }
#line 2281 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__UInt128__left); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__UInt128__left)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, other, rev");
    {
	SV *	self = ST(0)
;
	SV *	other = ST(1)
;
	SV *	rev = ST(2)
;
	SV *	RETVAL;
#line 1429 "Int128.xs"
    if (SvOK(rev)) {
        uint128_t a, b;
        if (SvTRUE(rev)) {
            a = SvU128(aTHX_ other);
            b = SvU128x(self);
        }
        else {
            b = SvU128(aTHX_ other);
            a = SvU128x(self);
        }
        RETVAL = newSVu128(aTHX_ (b > 128 ? 0 : a << b));
    }
    else {
        uint128_t b = SvU128(aTHX_ other);
        RETVAL = SvREFCNT_inc(self);
        SvU128x(self) <<= (b > 128 ? 128 : b);
    }
#line 2321 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__UInt128__right); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__UInt128__right)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, other, rev");
    {
	SV *	self = ST(0)
;
	SV *	other = ST(1)
;
	SV *	rev = ST(2)
;
	SV *	RETVAL;
#line 1454 "Int128.xs"
    if (SvOK(rev)) {
        uint128_t a, b;
        if (SvTRUE(rev)) {
            a = SvU128(aTHX_ other);
            b = SvU128x(self);
        }
        else {
            b = SvU128(aTHX_ other);
            a = SvU128x(self);
        }
        RETVAL = newSVu128(aTHX_ (b > 128 ? 0 : a >> b));
    }
    else {
        uint128_t b = SvU128(aTHX_ other);
        RETVAL = SvREFCNT_inc(self);
        SvU128x(self) >>= (b > 128 ? 128 : b);
    }
#line 2361 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__UInt128__pow); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__UInt128__pow)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "self, other, rev = &PL_sv_no");
    {
	SV *	self = ST(0)
;
	SV *	other = ST(1)
;
	SV *	rev;
#line 1479 "Int128.xs"
    uint128_t r;
    int128_t a, b;
#line 2384 "Int128.c"
	SV *	RETVAL;

	if (items < 3)
	    rev = &PL_sv_no;
	else {
	    rev = ST(2)
;
	}
#line 1482 "Int128.xs"
    if (SvTRUE(rev)) {
        a = SvU128(aTHX_ other);
        b = SvU128x(self);
    }
    else {
        a = SvU128x(self);
        b = SvU128(aTHX_ other);
    }
    r = powU128(aTHX_ a, b);
    if (SvOK(rev))
        RETVAL = newSVu128(aTHX_ r);
    else {
        RETVAL = self;
        SvREFCNT_inc(RETVAL);
        SvU128x(self) = r;
    }
#line 2410 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__UInt128__spaceship); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__UInt128__spaceship)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, other, rev");
    {
	SV *	self = ST(0)
;
	SV *	other = ST(1)
;
	SV *	rev = ST(2)
;
#line 1507 "Int128.xs"
    uint128_t left;
    uint128_t right;
#line 2434 "Int128.c"
	int	RETVAL;
	dXSTARG;
#line 1510 "Int128.xs"
    if (SvTRUE(rev)) {
        left = SvU128(aTHX_ other);
        right = SvU128x(self);
    }
    else {
        left = SvU128x(self);
        right = SvU128(aTHX_ other);
    }
    RETVAL = (left < right ? -1 : left > right ? 1 : 0);
#line 2447 "Int128.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__UInt128__eqn); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__UInt128__eqn)
{
    dVAR; dXSARGS;
    if (items < 2)
       croak_xs_usage(cv,  "self, other, ...");
    {
	SV *	self = ST(0)
;
	SV *	other = ST(1)
;
	SV *	RETVAL;
#line 1527 "Int128.xs"
    RETVAL = ( SvU128x(self) == SvU128(aTHX_ other)
               ? &PL_sv_yes
               : &PL_sv_no );
#line 2470 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__UInt128__nen); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__UInt128__nen)
{
    dVAR; dXSARGS;
    if (items < 2)
       croak_xs_usage(cv,  "self, other, ...");
    {
	SV *	self = ST(0)
;
	SV *	other = ST(1)
;
	SV *	RETVAL;
#line 1538 "Int128.xs"
    RETVAL = ( SvU128x(self) != SvU128(aTHX_ other)
               ? &PL_sv_yes
               : &PL_sv_no );
#line 2494 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__UInt128__gtn); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__UInt128__gtn)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, other, rev");
    {
	SV *	self = ST(0)
;
	SV *	other = ST(1)
;
	SV *	rev = ST(2)
;
	SV *	RETVAL;
#line 1550 "Int128.xs"
    if (SvTRUE(rev))
        RETVAL = SvU128x(self) < SvU128(aTHX_ other) ? &PL_sv_yes : &PL_sv_no;
    else
        RETVAL = SvU128x(self) > SvU128(aTHX_ other) ? &PL_sv_yes : &PL_sv_no;
#line 2521 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__UInt128__ltn); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__UInt128__ltn)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, other, rev");
    {
	SV *	self = ST(0)
;
	SV *	other = ST(1)
;
	SV *	rev = ST(2)
;
	SV *	RETVAL;
#line 1563 "Int128.xs"
    if (SvTRUE(rev))
        RETVAL = SvU128x(self) > SvU128(aTHX_ other) ? &PL_sv_yes : &PL_sv_no;
    else
        RETVAL = SvU128x(self) < SvU128(aTHX_ other) ? &PL_sv_yes : &PL_sv_no;
#line 2548 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__UInt128__gen); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__UInt128__gen)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, other, rev");
    {
	SV *	self = ST(0)
;
	SV *	other = ST(1)
;
	SV *	rev = ST(2)
;
	SV *	RETVAL;
#line 1576 "Int128.xs"
    if (SvTRUE(rev))
        RETVAL = SvU128x(self) <= SvU128(aTHX_ other) ? &PL_sv_yes : &PL_sv_no;
    else
        RETVAL = SvU128x(self) >= SvU128(aTHX_ other) ? &PL_sv_yes : &PL_sv_no;
#line 2575 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__UInt128__len); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__UInt128__len)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, other, rev");
    {
	SV *	self = ST(0)
;
	SV *	other = ST(1)
;
	SV *	rev = ST(2)
;
	SV *	RETVAL;
#line 1589 "Int128.xs"
    if (SvTRUE(rev))
        RETVAL = SvU128x(self) >= SvU128(aTHX_ other) ? &PL_sv_yes : &PL_sv_no;
    else
        RETVAL = SvU128x(self) <= SvU128(aTHX_ other) ? &PL_sv_yes : &PL_sv_no;
#line 2602 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__UInt128__and); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__UInt128__and)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, other, rev");
    {
	SV *	self = ST(0)
;
	SV *	other = ST(1)
;
	SV *	rev = ST(2)
;
	SV *	RETVAL;
#line 1602 "Int128.xs"
    if (SvOK(rev))
        RETVAL = newSVu128(aTHX_ SvU128x(self) & SvU128(aTHX_ other));
    else {
        RETVAL = self;
        SvREFCNT_inc(RETVAL);
        SvU128x(self) &= SvU128(aTHX_ other);
    }
#line 2632 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__UInt128__or); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__UInt128__or)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, other, rev");
    {
	SV *	self = ST(0)
;
	SV *	other = ST(1)
;
	SV *	rev = ST(2)
;
	SV *	RETVAL;
#line 1618 "Int128.xs"
    if (SvOK(rev))
        RETVAL = newSVu128(aTHX_ SvU128x(self) | SvU128(aTHX_ other));
    else {
        RETVAL = self;
        SvREFCNT_inc(RETVAL);
        SvU128x(self) |= SvU128(aTHX_ other);
    }
#line 2662 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__UInt128__xor); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__UInt128__xor)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, other, rev");
    {
	SV *	self = ST(0)
;
	SV *	other = ST(1)
;
	SV *	rev = ST(2)
;
	SV *	RETVAL;
#line 1634 "Int128.xs"
    if (SvOK(rev))
        RETVAL = newSVu128(aTHX_ SvU128x(self) ^ SvU128(aTHX_ other));
    else {
        RETVAL = self;
        SvREFCNT_inc(RETVAL);
        SvU128x(self) ^= SvU128(aTHX_ other);
    }
#line 2692 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__UInt128__not); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__UInt128__not)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "self, ...");
    {
	SV *	self = ST(0)
;
	SV *	RETVAL;
#line 1648 "Int128.xs"
    RETVAL = SvU128x(self) ? &PL_sv_no : &PL_sv_yes;
#line 2712 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__UInt128__bnot); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__UInt128__bnot)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "self, ...");
    {
	SV *	self = ST(0)
;
	SV *	RETVAL;
#line 1656 "Int128.xs"
    RETVAL = newSVu128(aTHX_ ~SvU128x(self));
#line 2732 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__UInt128__neg); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__UInt128__neg)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "self, ...");
    {
	SV *	self = ST(0)
;
	SV *	RETVAL;
#line 1664 "Int128.xs"
    RETVAL = newSVu128(aTHX_ -SvU128x(self));
#line 2752 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__UInt128__bool); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__UInt128__bool)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "self, ...");
    {
	SV *	self = ST(0)
;
	SV *	RETVAL;
#line 1672 "Int128.xs"
    RETVAL = SvU128x(self) ? &PL_sv_yes : &PL_sv_no;
#line 2772 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__UInt128__number); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__UInt128__number)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "self, ...");
    {
	SV *	self = ST(0)
;
	SV *	RETVAL;
#line 1680 "Int128.xs"
    RETVAL = su128_to_number(aTHX_ self);
#line 2792 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__UInt128__clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__UInt128__clone)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "self, ...");
    {
	SV *	self = ST(0)
;
	SV *	RETVAL;
#line 1688 "Int128.xs"
    RETVAL = newSVu128(aTHX_ SvU128x(self));
#line 2812 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__UInt128__string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__UInt128__string)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "self, ...");
    {
	SV *	self = ST(0)
;
	SV *	RETVAL;
#line 1696 "Int128.xs"
    RETVAL = newSV(I128STRLEN);
    SvPOK_on(RETVAL);
    SvCUR_set(RETVAL, u128_to_string(SvU128x(self), SvPVX(RETVAL)));
#line 2834 "Int128.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__Int128_int128_set); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_int128_set)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "self, a=NULL");
    {
	SV *	self = ST(0)
;
	SV *	a;

	if (items < 2)
	    a = NULL;
	else {
	    a = ST(1)
;
	}
#line 1711 "Int128.xs"
    SvI128x(self) = (a ? SvI128(aTHX_ a) : 0);
#line 2861 "Int128.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Math__Int128_int128_inc); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_int128_inc)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, a");
    {
	SV *	self = ST(0)
;
	int128_t        a = SvI128(aTHX_ ST(1))
;
#line 1718 "Int128.xs"
    if ( may_die_on_overflow && (a == INT128_MAX)) overflow(aTHX_ inc_error);
    SvI128x(self) = a + 1;
#line 2881 "Int128.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Math__Int128_int128_dec); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_int128_dec)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, a");
    {
	SV *	self = ST(0)
;
	int128_t        a = SvI128(aTHX_ ST(1))
;
#line 1726 "Int128.xs"
    if ( may_die_on_overflow && (a == INT128_MIN)) overflow(aTHX_ dec_error);
    SvI128x(self) = a - 1;
#line 2901 "Int128.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Math__Int128_int128_add); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_int128_add)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, a, b");
    {
	SV *	self = ST(0)
;
	int128_t        a = SvI128(aTHX_ ST(1))
;
	int128_t        b = SvI128(aTHX_ ST(2))
;
#line 1735 "Int128.xs"
    if ( may_die_on_overflow &&
         ( a > 0
           ? ( (b > 0) && (INT128_MAX - a < b) )
           : ( (b < 0) && (INT128_MIN - a > b) ) ) ) overflow(aTHX_ add_error);
    SvI128x(self) = a + b;
#line 2926 "Int128.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Math__Int128_int128_sub); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_int128_sub)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, a, b");
    {
	SV *	self = ST(0)
;
	int128_t        a = SvI128(aTHX_ ST(1))
;
	int128_t        b = SvI128(aTHX_ ST(2))
;
#line 1747 "Int128.xs"
    if ( may_die_on_overflow &&
         ( a > 0
           ? ( (b < 0) && (a - INT128_MAX > b) )
           : ( (b > 0) && (a - INT128_MIN < b) ) ) ) overflow(aTHX_ sub_error);
    SvI128x(self) = a - b;
#line 2951 "Int128.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Math__Int128_int128_mul); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_int128_mul)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, a1, b1");
    {
	SV *	self = ST(0)
;
	int128_t        a1 = SvI128(aTHX_ ST(1))
;
	int128_t        b1 = SvI128(aTHX_ ST(2))
;
#line 1759 "Int128.xs"
    if (may_die_on_overflow) {
        int neg = 0;
        uint128_t a, b;
        if (a1 < 0) {
            a = -a1;
            neg ^= 1;
        }
        else a = a1;
        if (b1 < 0) {
            b = -b1;
            neg ^= 1;
        }
        else b = b1;
        if (a < b) {
            uint128_t tmp = a;
            a = b; b = tmp;
        }
        mul_check_overflow(aTHX_ a, b, mul_error);
        if (a * b > (neg ? (~(uint128_t)INT128_MIN + 1) : INT128_MAX)) overflow(aTHX_ mul_error);
    }
    SvI128x(self) = a1 * b1;
#line 2992 "Int128.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Math__Int128_int128_pow); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_int128_pow)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, a, b");
    {
	SV *	self = ST(0)
;
	int128_t        a = SvI128(aTHX_ ST(1))
;
	int128_t        b = SvI128(aTHX_ ST(2))
;
#line 1787 "Int128.xs"
    int sign;
    uint128_t r;
#line 3014 "Int128.c"
#line 1790 "Int128.xs"
    if (a < 0) {
        sign = ((b & 1) ? -1 : 1);
        a = -a;
    }
    else sign = 1;
    if (b < 0) {
        if      (a == 0) croak_string(aTHX_ div_by_0_error);
        else if (a == 1) r = sign;
        else             r = 0;
    }
    else {
        uint128_t u = powU128(aTHX_ a, b);
        if (may_die_on_overflow && (u > ((sign < 0) ? (~(uint128_t)INT128_MIN + 1) : INT128_MAX))) overflow(aTHX_ pow_error);
        r = ((sign > 0) ? u : -u);
    }
    SvI128x(self) = r;
#line 3032 "Int128.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Math__Int128_int128_div); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_int128_div)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, a, b");
    {
	SV *	self = ST(0)
;
	int128_t        a = SvI128(aTHX_ ST(1))
;
	int128_t        b = SvI128(aTHX_ ST(2))
;
#line 1813 "Int128.xs"
    if (!b) croak_string(aTHX_ div_by_0_error);
    SvI128x(self) = a / b;
#line 3054 "Int128.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Math__Int128_int128_mod); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_int128_mod)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, a, b");
    {
	SV *	self = ST(0)
;
	int128_t        a = SvI128(aTHX_ ST(1))
;
	int128_t        b = SvI128(aTHX_ ST(2))
;
#line 1822 "Int128.xs"
    if (!b) croak_string(aTHX_ div_by_0_error);
    SvI128x(self) = a % b;
#line 3076 "Int128.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Math__Int128_int128_divmod); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_int128_divmod)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "self, rem, a, b");
    {
	SV *	self = ST(0)
;
	SV *	rem = ST(1)
;
	int128_t        a = SvI128(aTHX_ ST(2))
;
	int128_t        b = SvI128(aTHX_ ST(3))
;
#line 1832 "Int128.xs"
    int128_t d;
#line 3099 "Int128.c"
#line 1834 "Int128.xs"
    if (!b) croak_string(aTHX_ div_by_0_error);
    SvI128x(self) = d = a / b;
    SvI128x(rem) = a - b * d;
#line 3104 "Int128.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Math__Int128_int128_not); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_int128_not)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, a");
    {
	SV *	self = ST(0)
;
	int128_t        a = SvI128(aTHX_ ST(1))
;
#line 1843 "Int128.xs"
    SvI128x(self) = ~a;
#line 3123 "Int128.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Math__Int128_int128_neg); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_int128_neg)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, a");
    {
	SV *	self = ST(0)
;
	int128_t        a = SvI128(aTHX_ ST(1))
;
#line 1850 "Int128.xs"
    SvI128x(self) = -a;
#line 3142 "Int128.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Math__Int128_int128_and); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_int128_and)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, a, b");
    {
	SV *	self = ST(0)
;
	int128_t        a = SvI128(aTHX_ ST(1))
;
	int128_t        b = SvI128(aTHX_ ST(2))
;
#line 1858 "Int128.xs"
    SvI128x(self) = a & b;
#line 3163 "Int128.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Math__Int128_int128_or); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_int128_or)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, a, b");
    {
	SV *	self = ST(0)
;
	int128_t        a = SvI128(aTHX_ ST(1))
;
	int128_t        b = SvI128(aTHX_ ST(2))
;
#line 1866 "Int128.xs"
    SvI128x(self) = a | b;
#line 3184 "Int128.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Math__Int128_int128_xor); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_int128_xor)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, a, b");
    {
	SV *	self = ST(0)
;
	int128_t        a = SvI128(aTHX_ ST(1))
;
	int128_t        b = SvI128(aTHX_ ST(2))
;
#line 1874 "Int128.xs"
    SvI128x(self) = a ^ b;
#line 3205 "Int128.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Math__Int128_int128_left); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_int128_left)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, a, b");
    {
	SV *	self = ST(0)
;
	int128_t        a = SvI128(aTHX_ ST(1))
;
	uint128_t        b = SvU128(aTHX_ ST(2))
;
#line 1882 "Int128.xs"
    SvI128x(self) = (b > 127 ? 0 : a << b);
#line 3226 "Int128.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Math__Int128_int128_right); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_int128_right)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, a, b");
    {
	SV *	self = ST(0)
;
	int128_t        a = SvI128(aTHX_ ST(1))
;
	uint128_t        b = SvU128(aTHX_ ST(2))
;
#line 1890 "Int128.xs"
    SvI128x(self) = (b > 127 ? (a < 0 ? - 1 : 0) : a >> b);
#line 3247 "Int128.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Math__Int128_int128_average); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_int128_average)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, a, b");
    {
	SV *	self = ST(0)
;
	int128_t        a = SvI128(aTHX_ ST(1))
;
	int128_t        b = SvI128(aTHX_ ST(2))
;
#line 1898 "Int128.xs"
    SvI128x(self) = (a & b) + ((a ^ b) / 2);
#line 3268 "Int128.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Math__Int128_int128_min); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_int128_min)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, a, b");
    {
	SV *	self = ST(0)
;
	int128_t        a = SvI128(aTHX_ ST(1))
;
	int128_t        b = SvI128(aTHX_ ST(2))
;
#line 1906 "Int128.xs"
    SvI128x(self) = (a > b ? b : a);
#line 3289 "Int128.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Math__Int128_int128_max); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_int128_max)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, a, b");
    {
	SV *	self = ST(0)
;
	int128_t        a = SvI128(aTHX_ ST(1))
;
	int128_t        b = SvI128(aTHX_ ST(2))
;
#line 1914 "Int128.xs"
    SvI128x(self) = (a > b ? a : b);
#line 3310 "Int128.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Math__Int128_uint128_set); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_uint128_set)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "self, a=0");
    {
	SV *	self = ST(0)
;
	uint128_t	a;

	if (items < 2)
	    a = 0;
	else {
	a = SvU128(aTHX_ ST(1))
;
	}
#line 1925 "Int128.xs"
    SvU128x(self) = a;
#line 3335 "Int128.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Math__Int128_uint128_inc); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_uint128_inc)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, a");
    {
	SV *	self = ST(0)
;
	uint128_t        a = SvU128(aTHX_ ST(1))
;
#line 1932 "Int128.xs"
    if ( may_die_on_overflow && (a == INT128_MAX)) overflow(aTHX_ inc_error);
    SvU128x(self) = a + 1;
#line 3355 "Int128.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Math__Int128_uint128_dec); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_uint128_dec)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, a");
    {
	SV *	self = ST(0)
;
	uint128_t        a = SvU128(aTHX_ ST(1))
;
#line 1940 "Int128.xs"
    if ( may_die_on_overflow && (a == 0)) overflow(aTHX_ dec_error);
    SvU128x(self) = a - 1;
#line 3375 "Int128.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Math__Int128_uint128_add); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_uint128_add)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, a, b");
    {
	SV *	self = ST(0)
;
	uint128_t        a = SvU128(aTHX_ ST(1))
;
	uint128_t        b = SvU128(aTHX_ ST(2))
;
#line 1949 "Int128.xs"
    if (may_die_on_overflow && (UINT128_MAX - a < b)) overflow(aTHX_ add_error);
    SvU128x(self) = a + b;
#line 3397 "Int128.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Math__Int128_uint128_sub); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_uint128_sub)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, a, b");
    {
	SV *	self = ST(0)
;
	uint128_t        a = SvU128(aTHX_ ST(1))
;
	uint128_t        b = SvU128(aTHX_ ST(2))
;
#line 1958 "Int128.xs"
    if (may_die_on_overflow && (b > a)) overflow(aTHX_ sub_error);
    SvU128x(self) = a - b;
#line 3419 "Int128.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Math__Int128_uint128_mul); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_uint128_mul)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, a, b");
    {
	SV *	self = ST(0)
;
	uint128_t        a = SvU128(aTHX_ ST(1))
;
	uint128_t        b = SvU128(aTHX_ ST(2))
;
#line 1967 "Int128.xs"
    if (may_die_on_overflow)
        mul_check_overflow(aTHX_ a, b, mul_error);
    SvU128x(self) = a * b;
#line 3442 "Int128.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Math__Int128_uint128_pow); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_uint128_pow)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, a, b");
    {
	SV *	self = ST(0)
;
	uint128_t        a = SvU128(aTHX_ ST(1))
;
	uint128_t        b = SvU128(aTHX_ ST(2))
;
#line 1977 "Int128.xs"
    SvU128x(self) = powU128(aTHX_ a, b);
#line 3463 "Int128.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Math__Int128_uint128_div); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_uint128_div)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, a, b");
    {
	SV *	self = ST(0)
;
	uint128_t        a = SvU128(aTHX_ ST(1))
;
	uint128_t        b = SvU128(aTHX_ ST(2))
;
#line 1985 "Int128.xs"
    if (!b) croak_string(aTHX_ div_by_0_error);
    SvU128x(self) = a / b;
#line 3485 "Int128.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Math__Int128_uint128_mod); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_uint128_mod)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, a, b");
    {
	SV *	self = ST(0)
;
	uint128_t        a = SvU128(aTHX_ ST(1))
;
	uint128_t        b = SvU128(aTHX_ ST(2))
;
#line 1994 "Int128.xs"
    if (!b) croak_string(aTHX_ div_by_0_error);
    SvU128x(self) = a % b;
#line 3507 "Int128.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Math__Int128_uint128_divmod); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_uint128_divmod)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "self, rem, a, b");
    {
	SV *	self = ST(0)
;
	SV *	rem = ST(1)
;
	uint128_t        a = SvU128(aTHX_ ST(2))
;
	uint128_t        b = SvU128(aTHX_ ST(3))
;
#line 2004 "Int128.xs"
    uint128_t d;
#line 3530 "Int128.c"
#line 2006 "Int128.xs"
    if (!b) croak_string(aTHX_ div_by_0_error);
    SvU128x(self) = d = a / b;
    SvU128x(rem) = a - b * d;
#line 3535 "Int128.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Math__Int128_uint128_not); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_uint128_not)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, a");
    {
	SV *	self = ST(0)
;
	uint128_t        a = SvU128(aTHX_ ST(1))
;
#line 2015 "Int128.xs"
    SvU128x(self) = ~a;
#line 3554 "Int128.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Math__Int128_uint128_neg); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_uint128_neg)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, a");
    {
	SV *	self = ST(0)
;
	uint128_t        a = SvU128(aTHX_ ST(1))
;
#line 2022 "Int128.xs"
    SvU128x(self) = -a;
#line 3573 "Int128.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Math__Int128_uint128_and); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_uint128_and)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, a, b");
    {
	SV *	self = ST(0)
;
	uint128_t        a = SvU128(aTHX_ ST(1))
;
	uint128_t        b = SvU128(aTHX_ ST(2))
;
#line 2030 "Int128.xs"
    SvU128x(self) = a & b;
#line 3594 "Int128.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Math__Int128_uint128_or); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_uint128_or)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, a, b");
    {
	SV *	self = ST(0)
;
	uint128_t        a = SvU128(aTHX_ ST(1))
;
	uint128_t        b = SvU128(aTHX_ ST(2))
;
#line 2038 "Int128.xs"
    SvU128x(self) = a | b;
#line 3615 "Int128.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Math__Int128_uint128_xor); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_uint128_xor)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, a, b");
    {
	SV *	self = ST(0)
;
	uint128_t        a = SvU128(aTHX_ ST(1))
;
	uint128_t        b = SvU128(aTHX_ ST(2))
;
#line 2046 "Int128.xs"
    SvU128x(self) = a ^ b;
#line 3636 "Int128.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Math__Int128_uint128_left); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_uint128_left)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, a, b");
    {
	SV *	self = ST(0)
;
	uint128_t        a = SvU128(aTHX_ ST(1))
;
	uint128_t        b = SvU128(aTHX_ ST(2))
;
#line 2054 "Int128.xs"
    SvU128x(self) = (b > 127 ? 0 : a << b);
#line 3657 "Int128.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Math__Int128_uint128_right); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_uint128_right)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, a, b");
    {
	SV *	self = ST(0)
;
	uint128_t        a = SvU128(aTHX_ ST(1))
;
	uint128_t        b = SvU128(aTHX_ ST(2))
;
#line 2062 "Int128.xs"
    SvU128x(self) = (b > 127 ? 0 : a >> b);
#line 3678 "Int128.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Math__Int128_uint128_average); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_uint128_average)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, a, b");
    {
	SV *	self = ST(0)
;
	uint128_t        a = SvU128(aTHX_ ST(1))
;
	uint128_t        b = SvU128(aTHX_ ST(2))
;
#line 2070 "Int128.xs"
    SvU128x(self) = (a & b) + ((a ^ b) >> 1);
#line 3699 "Int128.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Math__Int128_mi128_uint128_min); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_mi128_uint128_min)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, a, b");
    {
	SV *	self = ST(0)
;
	uint128_t        a = SvU128(aTHX_ ST(1))
;
	uint128_t        b = SvU128(aTHX_ ST(2))
;
#line 2078 "Int128.xs"
    SvU128x(self) = (a > b ? b : a);
#line 3720 "Int128.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Math__Int128_mi128_uint128_max); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__Int128_mi128_uint128_max)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, a, b");
    {
	SV *	self = ST(0)
;
	uint128_t        a = SvU128(aTHX_ ST(1))
;
	uint128_t        b = SvU128(aTHX_ ST(2))
;
#line 2086 "Int128.xs"
    SvU128x(self) = (a > b ? a : b);
#line 3741 "Int128.c"
    }
    XSRETURN_EMPTY;
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_Math__Int128); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_Math__Int128)
{
    dVAR; dXSARGS;
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#endif
    XS_VERSION_BOOTCHECK;

        newXS("Math::Int128::CLONE", XS_Math__Int128_CLONE, file);
        newXS("Math::Int128::_set_may_die_on_overflow", XS_Math__Int128__set_may_die_on_overflow, file);
        newXS("Math::Int128::int128", XS_Math__Int128_int128, file);
        newXS("Math::Int128::uint128", XS_Math__Int128_uint128, file);
        newXS("Math::Int128::int128_to_number", XS_Math__Int128_int128_to_number, file);
        newXS("Math::Int128::uint128_to_number", XS_Math__Int128_uint128_to_number, file);
        newXS("Math::Int128::net_to_int128", XS_Math__Int128_net_to_int128, file);
        newXS("Math::Int128::net_to_uint128", XS_Math__Int128_net_to_uint128, file);
        newXS("Math::Int128::int128_to_net", XS_Math__Int128_int128_to_net, file);
        newXS("Math::Int128::uint128_to_net", XS_Math__Int128_uint128_to_net, file);
        newXS("Math::Int128::native_to_int128", XS_Math__Int128_native_to_int128, file);
        newXS("Math::Int128::native_to_uint128", XS_Math__Int128_native_to_uint128, file);
        newXS("Math::Int128::int128_to_native", XS_Math__Int128_int128_to_native, file);
        newXS("Math::Int128::uint128_to_native", XS_Math__Int128_uint128_to_native, file);
        newXS("Math::Int128::uint128_to_hex", XS_Math__Int128_uint128_to_hex, file);
        newXS("Math::Int128::int128_to_hex", XS_Math__Int128_int128_to_hex, file);
        newXS("Math::Int128::string_to_int128", XS_Math__Int128_string_to_int128, file);
        newXS("Math::Int128::string_to_uint128", XS_Math__Int128_string_to_uint128, file);
        newXS("Math::Int128::_inc", XS_Math__Int128__inc, file);
        newXS("Math::Int128::_dec", XS_Math__Int128__dec, file);
        newXS("Math::Int128::_add", XS_Math__Int128__add, file);
        newXS("Math::Int128::_sub", XS_Math__Int128__sub, file);
        newXS("Math::Int128::_mul", XS_Math__Int128__mul, file);
        newXS("Math::Int128::_div", XS_Math__Int128__div, file);
        newXS("Math::Int128::_remainder", XS_Math__Int128__remainder, file);
        newXS("Math::Int128::_left", XS_Math__Int128__left, file);
        newXS("Math::Int128::_right", XS_Math__Int128__right, file);
        newXS("Math::Int128::_pow", XS_Math__Int128__pow, file);
        newXS("Math::Int128::_spaceship", XS_Math__Int128__spaceship, file);
        newXS("Math::Int128::_eqn", XS_Math__Int128__eqn, file);
        newXS("Math::Int128::_nen", XS_Math__Int128__nen, file);
        newXS("Math::Int128::_gtn", XS_Math__Int128__gtn, file);
        newXS("Math::Int128::_ltn", XS_Math__Int128__ltn, file);
        newXS("Math::Int128::_gen", XS_Math__Int128__gen, file);
        newXS("Math::Int128::_len", XS_Math__Int128__len, file);
        newXS("Math::Int128::_and", XS_Math__Int128__and, file);
        newXS("Math::Int128::_or", XS_Math__Int128__or, file);
        newXS("Math::Int128::_xor", XS_Math__Int128__xor, file);
        newXS("Math::Int128::_not", XS_Math__Int128__not, file);
        newXS("Math::Int128::_bnot", XS_Math__Int128__bnot, file);
        newXS("Math::Int128::_neg", XS_Math__Int128__neg, file);
        newXS("Math::Int128::_bool", XS_Math__Int128__bool, file);
        newXS("Math::Int128::_number", XS_Math__Int128__number, file);
        newXS("Math::Int128::_clone", XS_Math__Int128__clone, file);
        newXS("Math::Int128::_string", XS_Math__Int128__string, file);
        newXS("Math::UInt128::_inc", XS_Math__UInt128__inc, file);
        newXS("Math::UInt128::_dec", XS_Math__UInt128__dec, file);
        newXS("Math::UInt128::_add", XS_Math__UInt128__add, file);
        newXS("Math::UInt128::_sub", XS_Math__UInt128__sub, file);
        newXS("Math::UInt128::_mul", XS_Math__UInt128__mul, file);
        newXS("Math::UInt128::_div", XS_Math__UInt128__div, file);
        newXS("Math::UInt128::_remainder", XS_Math__UInt128__remainder, file);
        newXS("Math::UInt128::_left", XS_Math__UInt128__left, file);
        newXS("Math::UInt128::_right", XS_Math__UInt128__right, file);
        newXS("Math::UInt128::_pow", XS_Math__UInt128__pow, file);
        newXS("Math::UInt128::_spaceship", XS_Math__UInt128__spaceship, file);
        newXS("Math::UInt128::_eqn", XS_Math__UInt128__eqn, file);
        newXS("Math::UInt128::_nen", XS_Math__UInt128__nen, file);
        newXS("Math::UInt128::_gtn", XS_Math__UInt128__gtn, file);
        newXS("Math::UInt128::_ltn", XS_Math__UInt128__ltn, file);
        newXS("Math::UInt128::_gen", XS_Math__UInt128__gen, file);
        newXS("Math::UInt128::_len", XS_Math__UInt128__len, file);
        newXS("Math::UInt128::_and", XS_Math__UInt128__and, file);
        newXS("Math::UInt128::_or", XS_Math__UInt128__or, file);
        newXS("Math::UInt128::_xor", XS_Math__UInt128__xor, file);
        newXS("Math::UInt128::_not", XS_Math__UInt128__not, file);
        newXS("Math::UInt128::_bnot", XS_Math__UInt128__bnot, file);
        newXS("Math::UInt128::_neg", XS_Math__UInt128__neg, file);
        newXS("Math::UInt128::_bool", XS_Math__UInt128__bool, file);
        newXS("Math::UInt128::_number", XS_Math__UInt128__number, file);
        newXS("Math::UInt128::_clone", XS_Math__UInt128__clone, file);
        newXS("Math::UInt128::_string", XS_Math__UInt128__string, file);
        newXS("Math::Int128::int128_set", XS_Math__Int128_int128_set, file);
        newXS("Math::Int128::int128_inc", XS_Math__Int128_int128_inc, file);
        newXS("Math::Int128::int128_dec", XS_Math__Int128_int128_dec, file);
        newXS("Math::Int128::int128_add", XS_Math__Int128_int128_add, file);
        newXS("Math::Int128::int128_sub", XS_Math__Int128_int128_sub, file);
        newXS("Math::Int128::int128_mul", XS_Math__Int128_int128_mul, file);
        newXS("Math::Int128::int128_pow", XS_Math__Int128_int128_pow, file);
        newXS("Math::Int128::int128_div", XS_Math__Int128_int128_div, file);
        newXS("Math::Int128::int128_mod", XS_Math__Int128_int128_mod, file);
        newXS("Math::Int128::int128_divmod", XS_Math__Int128_int128_divmod, file);
        newXS("Math::Int128::int128_not", XS_Math__Int128_int128_not, file);
        newXS("Math::Int128::int128_neg", XS_Math__Int128_int128_neg, file);
        newXS("Math::Int128::int128_and", XS_Math__Int128_int128_and, file);
        newXS("Math::Int128::int128_or", XS_Math__Int128_int128_or, file);
        newXS("Math::Int128::int128_xor", XS_Math__Int128_int128_xor, file);
        newXS("Math::Int128::int128_left", XS_Math__Int128_int128_left, file);
        newXS("Math::Int128::int128_right", XS_Math__Int128_int128_right, file);
        newXS("Math::Int128::int128_average", XS_Math__Int128_int128_average, file);
        newXS("Math::Int128::int128_min", XS_Math__Int128_int128_min, file);
        newXS("Math::Int128::int128_max", XS_Math__Int128_int128_max, file);
        newXS("Math::Int128::uint128_set", XS_Math__Int128_uint128_set, file);
        newXS("Math::Int128::uint128_inc", XS_Math__Int128_uint128_inc, file);
        newXS("Math::Int128::uint128_dec", XS_Math__Int128_uint128_dec, file);
        newXS("Math::Int128::uint128_add", XS_Math__Int128_uint128_add, file);
        newXS("Math::Int128::uint128_sub", XS_Math__Int128_uint128_sub, file);
        newXS("Math::Int128::uint128_mul", XS_Math__Int128_uint128_mul, file);
        newXS("Math::Int128::uint128_pow", XS_Math__Int128_uint128_pow, file);
        newXS("Math::Int128::uint128_div", XS_Math__Int128_uint128_div, file);
        newXS("Math::Int128::uint128_mod", XS_Math__Int128_uint128_mod, file);
        newXS("Math::Int128::uint128_divmod", XS_Math__Int128_uint128_divmod, file);
        newXS("Math::Int128::uint128_not", XS_Math__Int128_uint128_not, file);
        newXS("Math::Int128::uint128_neg", XS_Math__Int128_uint128_neg, file);
        newXS("Math::Int128::uint128_and", XS_Math__Int128_uint128_and, file);
        newXS("Math::Int128::uint128_or", XS_Math__Int128_uint128_or, file);
        newXS("Math::Int128::uint128_xor", XS_Math__Int128_uint128_xor, file);
        newXS("Math::Int128::uint128_left", XS_Math__Int128_uint128_left, file);
        newXS("Math::Int128::uint128_right", XS_Math__Int128_uint128_right, file);
        newXS("Math::Int128::uint128_average", XS_Math__Int128_uint128_average, file);
        newXS("Math::Int128::mi128_uint128_min", XS_Math__Int128_mi128_uint128_min, file);
        newXS("Math::Int128::mi128_uint128_max", XS_Math__Int128_mi128_uint128_max, file);

    /* Initialisation Section */

#line 544 "Int128.xs"
    init_stash_cache(aTHX);
    PERL_MATH_INT64_LOAD_OR_CROAK;
    INIT_C_API;

#line 3886 "Int128.c"

    /* End of Initialisation Section */

#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

